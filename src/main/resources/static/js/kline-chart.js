/**
 * K-line Chart Component using TradingView Lightweight Charts
 * KÁ∫øÂõæË°®ÁªÑ‰ª∂Ôºå‰ΩøÁî®TradingView Lightweight Charts
 */

class KlineChart {
    constructor(containerId, options = {}) {
        this.containerId = containerId;
        this.container = document.getElementById(containerId);
        this.chart = null;
        this.candlestickSeries = null;
        this.volumeSeries = null;
        this.symbol = options.symbol || 'BTCUSDT';
        this.timeframe = options.timeframe || '1m';
        this.lastKnownPrice = null; // Áî®‰∫éÂøÉË∑≥Êï∞ÊçÆÁöÑ‰ª∑Ê†ºÂèÇËÄÉ
        // ÂÆöÊó∂Âà∑Êñ∞Áõ∏ÂÖ≥
        this.refreshTimer = null;
        this.refreshInterval = 3000; // 3ÁßíÂà∑Êñ∞‰∏ÄÊ¨°
        this.isRefreshing = false;
        this.autoRefreshEnabled = true;

        // Chart configuration - Dark theme chart configuration
        // Âª∂ËøüËé∑ÂèñÂÆπÂô®Â∞∫ÂØ∏ÔºåÈÅøÂÖçÂú®DOMÊú™ÂáÜÂ§áÂ•ΩÊó∂ËÆøÈóÆ
        const getContainerWidth = () => {
            if (!this.container) return 800; // ÈªòËÆ§ÂÆΩÂ∫¶
            const width = this.container.clientWidth;
            return width > 0 ? width : 800; // Á°Æ‰øùÊúâÊúÄÂ∞èÂÆΩÂ∫¶
        };

        this.chartOptions = {
            width: getContainerWidth(),
            height: options.height || 400,
            layout: {
                backgroundColor: '#181A20',
                textColor: '#EAECEF',
            },
            grid: {
                vertLines: {
                    color: '#2B2F36',
                },
                horzLines: {
                    color: '#2B2F36',
                },
            },
            crosshair: {
                mode: 0, // CrosshairMode.Normal
                vertLine: {
                    color: '#F0B90B',
                    width: 1,
                    labelBackgroundColor: '#F0B90B',
                },
                horzLine: {
                    color: '#F0B90B',
                    width: 1,
                    labelBackgroundColor: '#F0B90B',
                },
            },
            rightPriceScale: {
                borderColor: '#2B2F36',
                textColor: '#EAECEF',
            },
            timeScale: {
                borderColor: '#2B2F36',
                textColor: '#EAECEF',
                timeVisible: true,
                secondsVisible: false,
            },
        };

        this.init();
    }

    /**
     * Initialize chart - ÂàùÂßãÂåñÂõæË°®
     */
    init() {
        try {
            // Check if LightweightCharts is available - Ê£ÄÊü•LightweightChartsÊòØÂê¶ÂèØÁî®
            if (typeof LightweightCharts === 'undefined') {
                throw new Error('LightweightCharts library not loaded');
            }

            console.log('LightweightCharts available:', !!LightweightCharts);
            console.log('createChart available:', typeof LightweightCharts.createChart);

            // È™åËØÅÂÆπÂô®ÂíåÈÖçÁΩÆ
            console.log('üîç Pre-chart creation validation:', {
                container: this.container,
                containerTagName: this.container ? this.container.tagName : null,
                containerId: this.containerId,
                containerInDOM: this.container ? document.contains(this.container) : false,
                chartOptions: this.chartOptions,
                optionsValid: this.chartOptions && typeof this.chartOptions === 'object'
            });

            // È™åËØÅchartOptions‰∏≠ÁöÑÂÖ≥ÈîÆÂ≠óÊÆµ
            if (!this.chartOptions || typeof this.chartOptions !== 'object') {
                throw new Error('Invalid chart options');
            }

            if (!this.container || !this.container.tagName) {
                throw new Error('Invalid container element');
            }

            // Create chart - ÂàõÂª∫ÂõæË°®
            console.log('üéØ Creating chart with options:', this.chartOptions);

            try {
                this.chart = LightweightCharts.createChart(this.container, this.chartOptions);
                console.log('‚úÖ Chart created successfully:', !!this.chart);
            } catch (chartCreationError) {
                console.error('‚ùå Failed to create chart:', chartCreationError);
                console.error('‚ùå Chart creation error details:', {
                    error: chartCreationError.message,
                    stack: chartCreationError.stack,
                    container: this.container,
                    containerWidth: this.container ? this.container.clientWidth : 'N/A',
                    containerHeight: this.container ? this.container.clientHeight : 'N/A',
                    chartOptions: this.chartOptions
                });
                throw chartCreationError;
            }

            console.log('Chart created:', !!this.chart);
            console.log('Chart methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(this.chart)));

            // Add candlestick series - Ê∑ªÂä†Ëú°ÁÉõÂõæÁ≥ªÂàó
            console.log('Available methods on chart:', Object.getOwnPropertyNames(this.chart));

            // Try different method names for different versions
            try {
                const seriesOptions = {
                    upColor: '#00C851',       // Green for up candles (Ê∂®)
                    downColor: '#FF4444',     // Red for down candles (Ë∑å)
                    borderVisible: false,
                    wickUpColor: '#00C851',   // Green wicks for up candles
                    wickDownColor: '#FF4444', // Red wicks for down candles
                };

                console.log('üîß Adding candlestick series with options:', seriesOptions);

                if (typeof this.chart.addCandlestickSeries === 'function') {
                    console.log('üìä Using addCandlestickSeries method');
                    this.candlestickSeries = this.chart.addCandlestickSeries(seriesOptions);
                } else if (typeof this.chart.addSeries === 'function') {
                    console.log('üìä Using addSeries method');
                    this.candlestickSeries = this.chart.addSeries('candlestick', seriesOptions);
                } else {
                    throw new Error('No suitable method found to add candlestick series');
                }

                console.log('‚úÖ Candlestick series created successfully:', !!this.candlestickSeries);

            } catch (seriesCreationError) {
                console.error('‚ùå Failed to create candlestick series:', seriesCreationError);
                console.error('‚ùå Series creation error details:', {
                    error: seriesCreationError.message,
                    stack: seriesCreationError.stack,
                    chartMethods: this.chart ? Object.getOwnPropertyNames(this.chart) : 'No chart'
                });
                throw seriesCreationError;
            }

            // Handle resize - Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èË∞ÉÊï¥
            this.handleResize();

            // Load initial data - Âä†ËΩΩÂàùÂßãÊï∞ÊçÆ
            this.loadInitialData();

            // Start auto-refresh timer - ÂêØÂä®Ëá™Âä®Âà∑Êñ∞ÂÆöÊó∂Âô®
            this.startAutoRefresh();

            // ÁõëÂê¨È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÔºåÂΩìÈ°µÈù¢ÈáçÊñ∞Âèò‰∏∫ÂèØËßÅÊó∂Á´ãÂç≥Âà∑Êñ∞‰∏ÄÊ¨°
            this.setupVisibilityChangeHandler();

            console.log('K-line chart initialized for', this.symbol, this.timeframe);

        } catch (error) {
            console.error('Failed to initialize K-line chart:', error);
            this.showError('ÂõæË°®ÂàùÂßãÂåñÂ§±Ë¥•');
        }
    }

    /**
     * Load initial K-line data - Âä†ËΩΩÂàùÂßãKÁ∫øÊï∞ÊçÆ
     */
    async loadInitialData() {
        console.log(`üìä Loading initial K-line data for ${this.symbol}/${this.timeframe}...`);

        try {
            const response = await fetch(`/api/kline/${this.symbol}?timeframe=${this.timeframe}&limit=100`);
            console.log(`üì° K-line API response status:`, response.status);

            if (!response.ok) {
                throw new Error(`Failed to fetch initial K-line data: ${response.status} ${response.statusText}`);
            }

            const klines = await response.json();
            console.log(`üìà Received K-line data:`, {
                responseType: typeof klines,
                isArray: Array.isArray(klines),
                count: klines ? klines.length : 0,
                firstData: klines && klines.length > 0 ? klines[0] : null,
                lastData: klines && klines.length > 0 ? klines[klines.length - 1] : null,
                rawResponse: klines
            });

            if (klines && klines.length > 0) {
                console.log(`üìä Processing ${klines.length} initial K-line records...`);
                const candleData = this.transformKlineData(klines);
                console.log(`üîÑ Transformed candle data:`, {
                    count: candleData.length,
                    firstCandle: candleData[0],
                    lastCandle: candleData[candleData.length - 1]
                });

                if (candleData && candleData.length > 0 && this.candlestickSeries) {
                    try {
                        // ÊúÄÂêé‰∏ÄÊ¨°Êï∞ÊçÆÈ™åËØÅ
                        const validData = candleData.filter(candle =>
                            candle &&
                            typeof candle === 'object' &&
                            candle.time &&
                            candle.time > 0 &&
                            !isNaN(candle.open) &&
                            !isNaN(candle.high) &&
                            !isNaN(candle.low) &&
                            !isNaN(candle.close)
                        );

                        if (validData.length === 0) {
                            console.warn('‚ö†Ô∏è All candle data was invalid after final validation');
                            this.showNoData();
                            return;
                        }

                        console.log(`üìä Setting ${validData.length} validated candles to chart (filtered from ${candleData.length})`);
                        this.candlestickSeries.setData(validData);

                        // Êõ¥Êñ∞ÊúÄÂêéÂ∑≤Áü•‰ª∑Ê†º
                        const lastCandle = validData[validData.length - 1];
                        if (lastCandle && lastCandle.close > 0) {
                            this.lastKnownPrice = lastCandle.close;
                        }

                        // Auto-fit visible range - Ëá™Âä®ÈÄÇÂ∫îÂèØËßÅËåÉÂõ¥
                        if (this.chart) {
                            this.chart.timeScale().fitContent();
                        }

                        console.log(`‚úÖ Loaded ${validData.length} initial K-line data points successfully (including zero-price data)`);
                        this.hideLoading();

                    } catch (chartError) {
                        console.error('‚ùå Error setting data to chart:', chartError);
                        console.error('‚ùå Chart error details:', {
                            error: chartError.message,
                            stack: chartError.stack,
                            dataLength: candleData.length,
                            firstCandle: candleData[0],
                            lastCandle: candleData[candleData.length - 1]
                        });
                        this.showError('ÂõæË°®Êï∞ÊçÆËÆæÁΩÆÂ§±Ë¥•: ' + chartError.message);
                    }
                } else {
                    console.warn('‚ö†Ô∏è No valid candle data after transformation');
                    this.showNoData();
                }
            } else {
                console.log('‚ö†Ô∏è No initial K-line data available from API');
                this.showNoData();
            }

        } catch (error) {
            console.error('‚ùå Error loading initial K-line data:', error);
            this.showError('Âä†ËΩΩKÁ∫øÊï∞ÊçÆÂ§±Ë¥•: ' + error.message);
        }
    }


    /**
     * Update chart with new K-line data - ‰ΩøÁî®Êñ∞ÁöÑKÁ∫øÊï∞ÊçÆÊõ¥Êñ∞ÂõæË°®
     */
    updateChart(kline) {
        try {
            console.log(`üîÑ Updating K-line chart with new data:`, kline);

            // È™åËØÅËæìÂÖ•Êï∞ÊçÆ
            if (!kline || typeof kline !== 'object') {
                console.error('‚ùå Invalid kline data for update:', kline);
                return;
            }

            const candleData = this.transformKlineData([kline])[0];
            console.log(`üîÑ Transformed candle data for chart:`, candleData);

            // È™åËØÅËΩ¨Êç¢ÂêéÁöÑÊï∞ÊçÆ
            if (!candleData || typeof candleData !== 'object') {
                console.error('‚ùå Failed to transform kline data or got null result');
                return;
            }

            // È™åËØÅÂøÖÈúÄÁöÑÊï∞ÊçÆÂ±ûÊÄß
            if (!candleData.time || candleData.time <= 0) {
                console.error('‚ùå Invalid or missing timestamp in candle data:', candleData);
                return;
            }

            const prices = [candleData.open, candleData.high, candleData.low, candleData.close];
            if (prices.some(price => price === null || price === undefined || isNaN(price))) {
                console.error('‚ùå Invalid prices in candle data:', candleData);
                return;
            }

            if (candleData && this.candlestickSeries && this.validateCandleData(candleData)) {
                try {
                    this.candlestickSeries.update(candleData);

                    // Êõ¥Êñ∞ÊúÄÂêéÂ∑≤Áü•‰ª∑Ê†ºÔºàÁî®‰∫éÂøÉË∑≥Êï∞ÊçÆÔºâ
                    if (candleData.close > 0) {
                        this.lastKnownPrice = candleData.close;
                    }

                    console.log(`‚úÖ K-line chart updated successfully:`, {
                        symbol: this.symbol,
                        timeframe: this.timeframe,
                        time: new Date(candleData.time * 1000),
                        ohlc: {
                            open: candleData.open,
                            high: candleData.high,
                            low: candleData.low,
                            close: candleData.close
                        },
                        lastKnownPrice: this.lastKnownPrice
                    });

                } catch (updateError) {
                    console.error('‚ùå Error updating chart with candle data:', updateError);
                    console.error('‚ùå Update error details:', {
                        error: updateError.message,
                        stack: updateError.stack,
                        candleData: candleData
                    });
                }
            } else {
                console.warn('‚ö†Ô∏è Cannot update chart: missing candleData or candlestickSeries', {
                    candleData: !!candleData,
                    candlestickSeries: !!this.candlestickSeries
                });
            }
        } catch (error) {
            console.error('‚ùå Error updating K-line chart:', error);
        }
    }

    /**
     * Get the last price from the current chart data - ‰ªéÂΩìÂâçÂõæË°®Êï∞ÊçÆËé∑ÂèñÊúÄÂêé‰ª∑Ê†º
     */
    getLastPrice() {
        try {
            if (this.candlestickSeries) {
                // Try to get data from the series (this might not be available in all versions)
                const lastData = this.lastKnownPrice;
                if (lastData && lastData > 0) {
                    return lastData;
                }
            }
            return null;
        } catch (error) {
            console.debug('Could not get last price from series:', error);
            return null;
        }
    }

    /**
     * Transform K-line data to chart format - Â∞ÜKÁ∫øÊï∞ÊçÆËΩ¨Êç¢‰∏∫ÂõæË°®Ê†ºÂºè
     */
    transformKlineData(klines) {
        if (!klines || !Array.isArray(klines)) {
            console.warn('‚ö†Ô∏è Invalid klines data provided to transform');
            return [];
        }

        return klines.map((kline, index) => {
            // È™åËØÅËæìÂÖ•Êï∞ÊçÆ
            if (!kline || typeof kline !== 'object') {
                console.warn(`‚ö†Ô∏è Invalid kline object at index ${index}:`, kline);
                return null;
            }

            // Á°Æ‰øùtimestampÊòØÊúâÊïàÁöÑÊï∞Â≠ó
            let timestamp = kline.timestamp;
            if (timestamp === null || timestamp === undefined) {
                console.warn(`‚ö†Ô∏è Null/undefined timestamp at index ${index}:`, timestamp);
                return null;
            }
            timestamp = parseFloat(timestamp);
            if (!timestamp || isNaN(timestamp) || !isFinite(timestamp) || timestamp <= 0) {
                console.warn(`‚ö†Ô∏è Invalid timestamp at index ${index}:`, timestamp);
                return null;
            }

            // È™åËØÅÊó∂Èó¥Êà≥Ê†ºÂºè - TradingViewÈúÄË¶ÅUnixÊó∂Èó¥Êà≥ÔºàÁßíÔºâ
            const now = Date.now() / 1000; // ÂΩìÂâçÊó∂Èó¥ÔºàÁßíÔºâ
            const oneYearAgo = now - (365 * 24 * 60 * 60); // ‰∏ÄÂπ¥ÂâçÔºàÁßíÔºâ
            const oneYearLater = now + (365 * 24 * 60 * 60); // ‰∏ÄÂπ¥ÂêéÔºàÁßíÔºâ

            if (timestamp < oneYearAgo || timestamp > oneYearLater) {
                console.warn(`‚ö†Ô∏è Timestamp seems to be in wrong format at index ${index}:`, {
                    timestamp: timestamp,
                    asDate: new Date(timestamp * 1000).toISOString(),
                    now: now,
                    nowAsDate: new Date(now * 1000).toISOString()
                });
            }

            // Ëß£Êûê‰ª∑Ê†ºÊï∞ÊçÆÂπ∂Á°Æ‰øùÊòØÊúâÊïàÊï∞Â≠ó
            const parsePrice = (value) => {
                if (value === null || value === undefined) return 0;
                const num = parseFloat(value);
                return isNaN(num) || !isFinite(num) ? 0 : num;
            };

            const transformedData = {
                time: timestamp,
                open: parsePrice(kline.open),
                high: parsePrice(kline.high),
                low: parsePrice(kline.low),
                close: parsePrice(kline.close),
            };

            console.log(`üìä Transforming K-line data at index ${index}:`, {
                original: kline,
                transformed: transformedData
            });

            // Â§ÑÁêÜ‰ª∑Ê†ºÂÖ®‰∏∫0ÁöÑÊÉÖÂÜµÔºàÂøÉË∑≥KÁ∫øÊï∞ÊçÆÔºâ
            const allPricesZero = transformedData.open === 0 && transformedData.high === 0 &&
                                 transformedData.low === 0 && transformedData.close === 0;

            if (allPricesZero) {
                console.log(`üíì Heartbeat K-line data (all prices zero) for timestamp ${kline.timestamp} - displaying as flat line`);
                // Ëé∑ÂèñÂâç‰∏Ä‰∏™KÁ∫øÁöÑÊî∂Áõò‰ª∑‰Ωú‰∏∫Ê∞¥Âπ≥Á∫ø‰ª∑Ê†ºÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàô‰ΩøÁî®ÂæàÂ∞èÁöÑÂÄº
                const lastPrice = this.getLastPrice();
                if (lastPrice && typeof lastPrice === 'number' && lastPrice > 0 && isFinite(lastPrice)) {
                    transformedData.open = lastPrice;
                    transformedData.high = lastPrice;
                    transformedData.low = lastPrice;
                    transformedData.close = lastPrice;
                    console.log(`üíì Using last known price ${lastPrice} for heartbeat line`);
                } else {
                    // Â¶ÇÊûúÊ≤°ÊúâÂéÜÂè≤‰ª∑Ê†ºÔºå‰ΩøÁî®0.001‰Ωú‰∏∫Ëµ∑ÂßãÂÄº
                    transformedData.open = 0.001;
                    transformedData.high = 0.001;
                    transformedData.low = 0.001;
                    transformedData.close = 0.001;
                    console.log(`üíì Using default price 0.001 for initial heartbeat line`);
                }
            } else {
                // È™åËØÅÊï∞ÊçÆÊúâÊïàÊÄßÔºà‰ªÖÂØπÈùûÈõ∂Êï∞ÊçÆËøõË°åÈ™åËØÅÔºâ
                if (transformedData.high < transformedData.low) {
                    console.warn('‚ö†Ô∏è Invalid K-line data: high < low', kline);
                    transformedData.high = Math.max(transformedData.open, transformedData.close);
                    transformedData.low = Math.min(transformedData.open, transformedData.close);
                }

                // Á°Æ‰øùhighËá≥Â∞ëÁ≠â‰∫émax(open, close)ÔºålowËá≥Â∞ëÁ≠â‰∫émin(open, close)
                if (transformedData.high < Math.max(transformedData.open, transformedData.close)) {
                    transformedData.high = Math.max(transformedData.open, transformedData.close);
                }
                if (transformedData.low > Math.min(transformedData.open, transformedData.close)) {
                    transformedData.low = Math.min(transformedData.open, transformedData.close);
                }
            }

            return transformedData;
        }).filter((data, index) => {
            // ËøáÊª§ÊéânullÂÄºÂíåÊó†ÊïàÊï∞ÊçÆ
            if (data === null || data === undefined) {
                console.warn(`‚ö†Ô∏è Filtered out null data at index ${index}`);
                return false;
            }

            // ËøáÊª§ÊéâÊó†ÊïàÊó∂Èó¥Êà≥ÁöÑÊï∞ÊçÆ
            if (!data.time || data.time <= 0) {
                console.warn(`‚ö†Ô∏è Filtered out invalid timestamp data:`, data);
                return false;
            }

            // Á°Æ‰øù‰ª∑Ê†ºÊï∞ÊçÆ‰∏çÂåÖÂê´null„ÄÅundefinedÊàñNaN
            const prices = [data.open, data.high, data.low, data.close];
            const hasInvalidPrice = prices.some(price =>
                price === null || price === undefined || isNaN(price) || !isFinite(price)
            );

            if (hasInvalidPrice) {
                console.warn(`‚ö†Ô∏è Filtered out data with invalid prices:`, data);
                return false;
            }

            // ÊúÄÂêéÈ™åËØÅÊâÄÊúâÂ±ûÊÄßÈÉΩ‰∏ç‰∏∫null
            if (data.time === null || data.time === undefined ||
                data.open === null || data.open === undefined ||
                data.high === null || data.high === undefined ||
                data.low === null || data.low === undefined ||
                data.close === null || data.close === undefined) {
                console.warn(`‚ö†Ô∏è Filtered out data with null values:`, data);
                return false;
            }

            return true;
        });
    }

    /**
     * Change timeframe - Êõ¥ÊîπÊó∂Èó¥Ê°ÜÊû∂
     */
    changeTimeframe(newTimeframe) {
        if (this.timeframe === newTimeframe) {
            return;
        }

        console.log('Changing timeframe from', this.timeframe, 'to', newTimeframe);

        // Update timeframe - Êõ¥Êñ∞Êó∂Èó¥Ê°ÜÊû∂
        this.timeframe = newTimeframe;

        // Clear chart data - Ê∏ÖÁ©∫ÂõæË°®Êï∞ÊçÆ
        if (this.candlestickSeries) {
            this.candlestickSeries.setData([]);
        }

        // Load new data - Âä†ËΩΩÊñ∞Êï∞ÊçÆ
        this.loadInitialData();
    }

    /**
     * Change symbol - Êõ¥Êîπ‰∫§ÊòìÂØπ
     */
    changeSymbol(newSymbol) {
        if (this.symbol === newSymbol) {
            return;
        }

        console.log('Changing symbol from', this.symbol, 'to', newSymbol);

        // Update symbol - Êõ¥Êñ∞‰∫§ÊòìÂØπ
        this.symbol = newSymbol;

        // Clear chart data - Ê∏ÖÁ©∫ÂõæË°®Êï∞ÊçÆ
        if (this.candlestickSeries) {
            this.candlestickSeries.setData([]);
        }

        // Load new data - Âä†ËΩΩÊñ∞Êï∞ÊçÆ
        this.loadInitialData();
    }


    /**
     * Handle window resize - Â§ÑÁêÜÁ™óÂè£Â§ßÂ∞èË∞ÉÊï¥
     */
    handleResize() {
        const resizeObserver = new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== this.container) {
                return;
            }

            const newRect = entries[0].contentRect;
            this.chart.applyOptions({
                width: newRect.width,
                height: newRect.height
            });
        });

        resizeObserver.observe(this.container);
    }

    /**
     * Show error message - ÊòæÁ§∫ÈîôËØØ‰ø°ÊÅØ
     */
    showError(message) {
        this.container.innerHTML = `
            <div class="d-flex align-items-center justify-content-center h-100 text-danger">
                <div class="text-center">
                    <i class="fas fa-exclamation-triangle fa-2x mb-2"></i>
                    <p>${message}</p>
                </div>
            </div>
        `;
    }

    /**
     * Show no data message - ÊòæÁ§∫Êó†Êï∞ÊçÆ‰ø°ÊÅØ
     */
    showNoData() {
        this.container.innerHTML = `
            <div class="d-flex align-items-center justify-content-center h-100 text-muted">
                <div class="text-center">
                    <i class="fas fa-chart-line fa-2x mb-2"></i>
                    <p>ÊöÇÊó†KÁ∫øÊï∞ÊçÆ</p>
                    <small>ÂºÄÂßã‰∫§ÊòìÂêéÂ∞ÜÊòæÁ§∫KÁ∫øÂõæ</small>
                </div>
            </div>
        `;
    }

    /**
     * Hide loading indicator - ÈöêËóèÂä†ËΩΩÊåáÁ§∫Âô®
     */
    hideLoading() {
        const loadingElement = this.container.querySelector('#kline-loading');
        if (loadingElement) {
            loadingElement.style.display = 'none';
        }
    }


    /**
     * Start auto-refresh timer - ÂêØÂä®Ëá™Âä®Âà∑Êñ∞ÂÆöÊó∂Âô®
     */
    startAutoRefresh() {
        if (!this.autoRefreshEnabled) {
            console.log('üîÑ Auto-refresh is disabled');
            return;
        }

        // Ê∏ÖÈô§Áé∞ÊúâÂÆöÊó∂Âô®
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
        }

        console.log(`üîÑ Starting auto-refresh every ${this.refreshInterval/1000} seconds`);

        this.refreshTimer = setInterval(() => {
            try {
                // Ê£ÄÊü•È°µÈù¢ÊòØÂê¶ÂèØËßÅÔºåÈÅøÂÖçÂú®ÂêéÂè∞Ê†áÁ≠æÈ°µ‰∏≠ËøõË°å‰∏çÂøÖË¶ÅÁöÑÂà∑Êñ∞
                if (document.hidden) {
                    console.log('üîÑ Page is hidden, skipping auto-refresh');
                    return;
                }

                this.refreshKlineData().catch(error => {
                    console.error('‚ùå Auto-refresh error:', error);
                });
            } catch (error) {
                console.error('‚ùå Auto-refresh timer error:', error);
            }
        }, this.refreshInterval);

        console.log('‚úÖ Auto-refresh timer started successfully');
    }

    /**
     * Stop auto-refresh timer - ÂÅúÊ≠¢Ëá™Âä®Âà∑Êñ∞ÂÆöÊó∂Âô®
     */
    stopAutoRefresh() {
        if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
            console.log('üîÑ Auto-refresh stopped');
        }
    }

    /**
     * Manual refresh K-line data - ÊâãÂä®Âà∑Êñ∞KÁ∫øÊï∞ÊçÆ
     */
    async refreshKlineData(forceReloadAll = false) {
        if (this.isRefreshing) {
            console.log('üîÑ Refresh already in progress, skipping...');
            return;
        }

        try {
            this.isRefreshing = true;
            const startTime = Date.now();
            console.log('üîÑ Refreshing K-line data...', {
                symbol: this.symbol,
                timeframe: this.timeframe,
                autoRefreshEnabled: this.autoRefreshEnabled,
                hasTimer: !!this.refreshTimer,
                forceReloadAll: forceReloadAll
            });

            // ÊòæÁ§∫Âà∑Êñ∞ÊåáÁ§∫Âô®
            this.showRefreshIndicator();

            if (forceReloadAll) {
                // ÂÆåÂÖ®ÈáçÊñ∞Âä†ËΩΩÊâÄÊúâÊï∞ÊçÆÔºàÁî®‰∫éÊâãÂä®Âà∑Êñ∞ÊàñÂàùÂßãÂä†ËΩΩÔºâ
                await this.loadInitialData();
            } else {
                // Âè™Êõ¥Êñ∞ÊúÄÊñ∞Êï∞ÊçÆÔºàÁî®‰∫éÂÆöÊó∂Âà∑Êñ∞Ôºâ
                await this.updateLatestKlineData();
            }

            const duration = Date.now() - startTime;
            console.log(`‚úÖ K-line data refreshed successfully in ${duration}ms`);

        } catch (error) {
            console.error('‚ùå Error refreshing K-line data:', error);
            // ÂèØÈÄâÔºöÊòæÁ§∫Áî®Êà∑ÂèãÂ•ΩÁöÑÈîôËØØÊèêÁ§∫
            this.showError('Êï∞ÊçÆÂà∑Êñ∞Â§±Ë¥•ÔºåËØ∑Á®çÂêéÈáçËØï');
        } finally {
            this.isRefreshing = false;
            // ÈöêËóèÂà∑Êñ∞ÊåáÁ§∫Âô®
            this.hideRefreshIndicator();
        }
    }

    /**
     * Update only the latest K-line data - Âè™Êõ¥Êñ∞ÊúÄÊñ∞ÁöÑKÁ∫øÊï∞ÊçÆ
     */
    async updateLatestKlineData() {
        console.log(`üìä Updating latest K-line data for ${this.symbol}/${this.timeframe}...`);

        try {
            // Ëé∑ÂèñÊúÄÊñ∞ÁöÑÂá†‰∏™KÁ∫øÊï∞ÊçÆÁÇπÔºàÁî®‰∫éÊõ¥Êñ∞ÂΩìÂâçÂë®ÊúüÔºâ
            const response = await fetch(`/api/kline/${this.symbol}?timeframe=${this.timeframe}&limit=2`);
            console.log(`üì° Latest K-line API response status:`, response.status);

            if (!response.ok) {
                throw new Error(`Failed to fetch latest K-line data: ${response.status} ${response.statusText}`);
            }

            const klines = await response.json();
            console.log(`üìà Received latest K-line data:`, {
                responseType: typeof klines,
                isArray: Array.isArray(klines),
                count: klines ? klines.length : 0,
                data: klines
            });

            if (klines && klines.length > 0 && this.candlestickSeries) {
                // ËΩ¨Êç¢ÊúÄÊñ∞ÁöÑKÁ∫øÊï∞ÊçÆ
                const candleData = this.transformKlineData(klines);
                console.log(`üîÑ Transformed latest candle data:`, candleData);

                if (candleData && candleData.length > 0) {
                    // Êõ¥Êñ∞ÊúÄÊñ∞ÁöÑÊï∞ÊçÆÁÇπÔºàÈÄöÂ∏∏ÊòØÂΩìÂâçÊú™ÂÆåÊàêÁöÑKÁ∫øÔºâ
                    const latestCandle = candleData[candleData.length - 1];

                    if (latestCandle && this.validateCandleData(latestCandle)) {
                        try {
                            console.log(`üìä Updating latest candle:`, latestCandle);
                            this.candlestickSeries.update(latestCandle);

                            // Êõ¥Êñ∞ÊúÄÂêéÂ∑≤Áü•‰ª∑Ê†º
                            if (latestCandle.close > 0) {
                                this.lastKnownPrice = latestCandle.close;
                            }

                            console.log(`‚úÖ Latest K-line data updated successfully`);
                        } catch (updateError) {
                            console.error('‚ùå Error updating latest candle:', updateError);
                            // Â¶ÇÊûúÊõ¥Êñ∞Â§±Ë¥•ÔºåÂèØËÉΩÊòØÂõ†‰∏∫Êó∂Èó¥Êà≥ÈóÆÈ¢òÔºåÂ∞ùËØïÈáçÊñ∞Âä†ËΩΩÊúÄËøëÁöÑÊï∞ÊçÆ
                            console.log('üîÑ Update failed, trying to add as new data point...');

                            // Â¶ÇÊûúÊúâÂ§ö‰∏™Êï∞ÊçÆÁÇπÔºåÊ∑ªÂä†‰πãÂâçÁöÑÊï∞ÊçÆÁÇπ
                            if (candleData.length > 1) {
                                const prevCandle = candleData[candleData.length - 2];
                                this.candlestickSeries.update(prevCandle);
                            }
                            this.candlestickSeries.update(latestCandle);
                        }
                    }
                }
            } else {
                console.log('‚ö†Ô∏è No latest K-line data available from API');
            }

        } catch (error) {
            console.error('‚ùå Error updating latest K-line data:', error);
            throw error; // ÈáçÊñ∞ÊäõÂá∫ÈîôËØØ‰ª•‰æø‰∏äÂ±ÇÂ§ÑÁêÜ
        }
    }

    /**
     * Validate candle data before passing to LightweightCharts - È™åËØÅKÁ∫øÊï∞ÊçÆ
     */
    validateCandleData(candle) {
        if (!candle || typeof candle !== 'object') {
            console.warn('‚ö†Ô∏è Invalid candle object:', candle);
            return false;
        }

        // Ê£ÄÊü•ÂøÖÈúÄÁöÑÂ±ûÊÄß
        const requiredProps = ['time', 'open', 'high', 'low', 'close'];
        for (const prop of requiredProps) {
            const value = candle[prop];
            if (value === null || value === undefined || isNaN(value) || !isFinite(value)) {
                console.warn(`‚ö†Ô∏è Invalid ${prop} value in candle:`, value, candle);
                return false;
            }
        }

        // Ê£ÄÊü•Êó∂Èó¥Êà≥ÊòØÂê¶ÊúâÊïà
        if (candle.time <= 0) {
            console.warn('‚ö†Ô∏è Invalid timestamp in candle:', candle.time);
            return false;
        }

        // Ê£ÄÊü•OHLCÂÖ≥Á≥ªÊòØÂê¶ÊúâÊïà
        if (candle.high < candle.low) {
            console.warn('‚ö†Ô∏è Invalid OHLC: high < low:', candle);
            return false;
        }

        return true;
    }

    /**
     * Show refresh indicator - ÊòæÁ§∫Âà∑Êñ∞ÊåáÁ§∫Âô®
     */
    showRefreshIndicator() {
        // Âú®ÂõæË°®ÂÆπÂô®‰∏äÊ∑ªÂä†Âà∑Êñ∞ÊåáÁ§∫Âô®
        if (!this.container) return;

        let refreshIndicator = this.container.querySelector('.refresh-indicator');
        if (!refreshIndicator) {
            refreshIndicator = document.createElement('div');
            refreshIndicator.className = 'refresh-indicator';
            refreshIndicator.innerHTML = `
                <div class="refresh-spinner">
                    <i class="fas fa-sync-alt fa-spin"></i>
                    <span>Âà∑Êñ∞‰∏≠...</span>
                </div>
            `;
            refreshIndicator.style.cssText = `
                position: absolute;
                top: 10px;
                right: 10px;
                z-index: 1000;
                background: rgba(0, 0, 0, 0.7);
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                display: flex;
                align-items: center;
                gap: 6px;
            `;
            this.container.style.position = 'relative';
            this.container.appendChild(refreshIndicator);
        } else {
            refreshIndicator.style.display = 'flex';
        }
    }

    /**
     * Hide refresh indicator - ÈöêËóèÂà∑Êñ∞ÊåáÁ§∫Âô®
     */
    hideRefreshIndicator() {
        if (!this.container) return;

        const refreshIndicator = this.container.querySelector('.refresh-indicator');
        if (refreshIndicator) {
            refreshIndicator.style.display = 'none';
        }
    }

    /**
     * Toggle auto-refresh - ÂàáÊç¢Ëá™Âä®Âà∑Êñ∞
     */
    toggleAutoRefresh() {
        this.autoRefreshEnabled = !this.autoRefreshEnabled;

        if (this.autoRefreshEnabled) {
            this.startAutoRefresh();
            console.log('‚úÖ Auto-refresh enabled');
        } else {
            this.stopAutoRefresh();
            console.log('üîÑ Auto-refresh disabled');
        }

        return this.autoRefreshEnabled;
    }

    /**
     * Set refresh interval - ËÆæÁΩÆÂà∑Êñ∞Èó¥Èöî
     */
    setRefreshInterval(intervalMs) {
        if (!intervalMs || intervalMs < 1000 || intervalMs > 300000) {
            console.warn('‚ö†Ô∏è Invalid refresh interval, must be between 1-300 seconds');
            return;
        }

        this.refreshInterval = intervalMs;

        // Â¶ÇÊûúËá™Âä®Âà∑Êñ∞Â∑≤ÂêØÁî®ÔºåÈáçÂêØÂÆöÊó∂Âô®‰ª•Â∫îÁî®Êñ∞Èó¥Èöî
        if (this.autoRefreshEnabled) {
            console.log(`üîÑ Restarting auto-refresh with new interval: ${intervalMs/1000} seconds`);
            this.stopAutoRefresh();
            this.startAutoRefresh();
        }

        console.log(`‚úÖ Refresh interval set to ${intervalMs/1000} seconds`);
    }

    /**
     * Setup page visibility change handler - ËÆæÁΩÆÈ°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÂ§ÑÁêÜ
     */
    setupVisibilityChangeHandler() {
        if (typeof document.addEventListener === 'undefined') {
            return; // ‰∏çÊîØÊåÅaddEventListenerÁöÑÊóßÊµèËßàÂô®
        }

        this.visibilityChangeHandler = () => {
            if (!document.hidden && this.autoRefreshEnabled) {
                console.log('üîÑ Page became visible, refreshing K-line data...');
                // È°µÈù¢Âèò‰∏∫ÂèØËßÅÊó∂Á´ãÂç≥Âà∑Êñ∞‰∏ÄÊ¨°ÔºàÂÆåÂÖ®ÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆÔºâ
                setTimeout(() => {
                    this.refreshKlineData(true).catch(error => {
                        console.error('‚ùå Visibility refresh error:', error);
                    });
                }, 100); // Á®çÂæÆÂª∂Ëøü‰ª•Á°Æ‰øùÈ°µÈù¢ÂÆåÂÖ®Âä†ËΩΩ
            }
        };

        document.addEventListener('visibilitychange', this.visibilityChangeHandler);
        console.log('‚úÖ Page visibility change handler setup complete');
    }

    /**
     * Remove page visibility change handler - ÁßªÈô§È°µÈù¢ÂèØËßÅÊÄßÂèòÂåñÂ§ÑÁêÜ
     */
    removeVisibilityChangeHandler() {
        if (this.visibilityChangeHandler && typeof document.removeEventListener !== 'undefined') {
            document.removeEventListener('visibilitychange', this.visibilityChangeHandler);
            this.visibilityChangeHandler = null;
            console.log('‚úÖ Page visibility change handler removed');
        }
    }

    /**
     * Destroy chart and cleanup - ÈîÄÊØÅÂõæË°®Âπ∂Ê∏ÖÁêÜ
     */
    destroy() {
        // ÂÅúÊ≠¢Ëá™Âä®Âà∑Êñ∞
        this.stopAutoRefresh();

        // ÁßªÈô§È°µÈù¢ÂèØËßÅÊÄßÂ§ÑÁêÜÂô®
        this.removeVisibilityChangeHandler();

        if (this.chart) {
            this.chart.remove();
            this.chart = null;
        }

        console.log('K-line chart destroyed');
    }
}

// Export for global use - ÂØºÂá∫‰æõÂÖ®Â±Ä‰ΩøÁî®
window.KlineChart = KlineChart;